# cmd1

题目来源：https://pwnable.kr/

这道题真的很简单，可惜就是脑子转不过弯，可能就是对 linux 不太熟悉。

依旧先来看一下源程序知道一下程序执行的流程：

```c
#include <stdio.h>
#include <string.h>

int filter(char* cmd){
	int r=0;
	r += strstr(cmd, "flag")!=0;
	r += strstr(cmd, "sh")!=0;
	r += strstr(cmd, "tmp")!=0;
	return r;
}
int main(int argc, char* argv[], char** envp){
	putenv("PATH=/thankyouverymuch");
	if(filter(argv[1])) return 0;
	system( argv[1] );
	return 0;
}
```

逻辑不复杂，main 函数中先使用 putenv 设置了环境变量，随后调用 filter 函数过滤输入，最后使用 system 函数执行输入的命令。

这里有几个点要说明，PATH 环境变量是和系统可执行文件有关的，如果需要执行某一个可执行文件，在没有给出这个文件的具体路径的时候，系统就会去 PATH 路径下搜索是否存在这样一个可执行文件。而使用 putenv 就可以更新环境变量，而这里是直接将原有的 PATH 修改了，这样会有什么问题？

> 有一点说明，在该进程中修改环境变量并不会对外部的全局变量有影响，换句话说这里修改只针对本进程可用。

system 的作用是执行某个命令，它**会继承环境变量**，并且它在执行命令的时候环境变量是受到本进程影响的，所以比如在这里直接执行 ls 是不行的，因为在 PATH 中根本找不到。

如果把 system 就看作是命令行执行，那么一共可能有三种执行一个命令的情况：

* 去 PATH 变量指定的路径中查找；
* 使用 ./[程序名] 就会在当前目录下执行；
* 使用绝对路径执行；

既然第一条走不通，那么就要尝试后面两种。如果选择使用第二种执行方式，那么需要想办法在其他目录下执行某个程序来显示 flag，做法是在 /tmp 文件夹下写一个 cat flag 的脚本，并且在执行 cmd1 程序时将当前目录切换到 /tmp，我们随后执行如下命令：

```shell
/home/cmd1/cmd1 ./[脚本名]
```

这样就可以执行当前目录下的脚本，而且和 filter 函数无关。

那么如果尝试使用第三种方法的话会有一个问题，就是它限制了执行的命令中不能有 sh 或者 flag 这样的单词。在 linux 中支持在命令中使用通配符这样的手段，正好用来绕过这个检测。

```
./cmd1 "/bin/cat fla*"
```

注意命令中必须使用绝对路径，因为程序中修改了环境变量。